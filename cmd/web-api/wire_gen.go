// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/xelarion/go-layout/internal/api/http/web"
	"github.com/xelarion/go-layout/internal/api/http/web/handler"
	"github.com/xelarion/go-layout/internal/api/http/web/middleware"
	"github.com/xelarion/go-layout/internal/api/http/web/service"
	"github.com/xelarion/go-layout/internal/api/http/web/swagger"
	"github.com/xelarion/go-layout/internal/infra/config"
	"github.com/xelarion/go-layout/internal/infra/server/http"
	"github.com/xelarion/go-layout/internal/repository"
	"github.com/xelarion/go-layout/internal/usecase"
	"github.com/xelarion/go-layout/pkg/app"
	"go.uber.org/zap"
)

// Injectors from wire.go:

// initApp initializes the Web API application with all needed resources.
// It sets up database connections, creates repositories, services, and middleware.
func initApp(cfgPG *config.PG, cfgRedis *config.Redis, cfgRabbitMQ *config.RabbitMQ, cfgHTTP *config.HTTP, cfgJWT *config.JWT, logger *zap.Logger) (*app.App, func(), error) {
	data, cleanup, err := repository.NewData(cfgPG, cfgRedis, cfgRabbitMQ, logger)
	if err != nil {
		return nil, nil, err
	}
	transaction := repository.NewTransaction(data)
	userRepository := repository.NewUserRepository(data)
	roleRepository := repository.NewRoleRepository(data)
	departmentRepository := repository.NewDepartmentRepository(data)
	userUseCase := usecase.NewUserUseCase(transaction, userRepository, roleRepository, departmentRepository)
	ginJWTMiddleware, err := middleware.NewAuthMiddleware(cfgJWT, userUseCase, logger)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	roleUseCase := usecase.NewRoleUseCase(transaction, roleRepository, userRepository)
	permissionMiddleware := middleware.NewPermissionMiddleware(roleUseCase, logger)
	authService := service.NewAuthService(userUseCase, roleUseCase, logger)
	authHandler := handler.NewAuthHandler(authService, ginJWTMiddleware, logger)
	departmentUseCase := usecase.NewDepartmentUseCase(transaction, departmentRepository, userRepository)
	departmentService := service.NewDepartmentService(departmentUseCase)
	departmentHandler := handler.NewDepartmentHandler(departmentService, logger)
	permissionUseCase := usecase.NewPermissionUseCase()
	permissionService := service.NewPermissionService(permissionUseCase, roleUseCase)
	permissionHandler := handler.NewPermissionHandler(permissionService, logger)
	roleService := service.NewRoleService(roleUseCase)
	roleHandler := handler.NewRoleHandler(roleService, logger)
	userService := service.NewUserService(userUseCase)
	userHandler := handler.NewUserHandler(userService, logger)
	router := web.NewRouter(logger, ginJWTMiddleware, permissionMiddleware, authHandler, departmentHandler, permissionHandler, roleHandler, userHandler)
	swaggerRouter := swagger.NewRouter()
	server := provideHTTPServer(cfgHTTP, logger, router, swaggerRouter)
	appApp := newApp(logger, server)
	return appApp, func() {
		cleanup()
	}, nil
}

// wire.go:

// provideHTTPServer provides the HTTP server instance.
func provideHTTPServer(cfgHTTP *config.HTTP, logger *zap.Logger, webRouter *web.Router, swaggerRouter *swagger.Router) *http.Server {
	hs := http.NewServer(
		cfgHTTP,
		logger, http.WithMiddleware(middleware.CORS(cfgHTTP.AllowOrigins)), http.WithMiddleware(middleware.Timeout(cfgHTTP.RequestTimeout)), http.WithMiddleware(middleware.Recovery(logger)), http.WithMiddleware(middleware.Error(logger)),
	)

	hs.RegisterRoutes(webRouter)
	hs.RegisterRoutes(swaggerRouter)

	return hs
}
